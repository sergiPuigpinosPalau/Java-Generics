# Java-Generics

## 1. Funcions
### 1.1. Tasca 1
A la tasca 1 creem la funció partition explicada en el document però sol utilitzant ints. Dins la funció creem dues llistes, una on es guarda els elements més petits que el pivot i l'altra on es guarda els elements més grans. Després s'agafa l'iterador que ens proporciona la llista i mentre l'iterador ens torni elements, anirem comprovant per element si aquest és més gran o més petit que el pivot i depenent de si ho és o no ho ficarà a una llista o a una altra. Després creem una instància de la classe PairOfLists (que guarda dues llistes) que sol accepta integers i li passem les dues llistes que hem creat.
### 1.2. Tasca 2
A la tasca 2 hem d'implementar la mateixa funció però utilitzant genèrics i implementar-la amb dues funcions diferents, una utilitzant elements comparables i l'altra utilitzant un comparador. La implementació de la funció és la mateixa que la de la tasca 1 però en aquest cas hem d'especificar que estem utilitzant genèrics. Per fer-ho, hem de substituir on teníem int per una E i també hem d'especificar que la funció treballa amb elements genèrics comparables ficant "E extends comparable" a la capçalera de la funció. També depenent de si la funció utilitza un comparador o elements comparables, es compararà d'una manera o d'una altra. Si la funció treballa amb comparables, és crida a la funció compareTo que ha heretat del pare o que té implementada la classe per poder comparar elements, i l'utilitzem per comparar els elements de la llista amb el pivot. Si la funció treballa amb comparador, s'utilitza el comparador que li passen pels arguments i crida a la funció "compare" per comparar els elements. Així per exemple podrem utilitzar el comparador d'Employees per comparar els Engineers. Com que Engineer és una subclasse d'Employee, tindrà les mateixes variables que s'utilitzen per comparar Employees. Finalment es crea la instància de PairOfLists (que guarda dues lliste) genèrica i li passem les dues llistes.
### 1.3. Tasca 3
La tasca 3 és molt semblant a la 2 però en aquest cas en comptes de crear una instància de la classe PairOfLists per guardar les dues llistes, guardem els elements en dues llistes que li passen pels arguments. El funcionament torna a ser molt semblant al de la tasca 2, on tenim dues funcions, una que compara amb comparables i l'altra amb comparador. Però en aquest cas, hem d'especificar que les llistes per guardar els elements poden ser de E o d'una superclasse d'ella. Així, donem la llibertat de poder passar una llista d'una altra classe mentre aquesta sigui superclasse de la qual s'està treballant. Per exemple podríem fer llistes d'Objectes que guardessin elements de la classe int. O en el nostre cas, una llista d'Employees emplenada amb diferents subclasses com Engineers i Mechanics.

## 2. Testos
### 2.1. partitionIntTest
Aquest test comprova el funcionament de la tasca 1. Es crea una llista d'ints i un pivot qualsevol i es crida a la funció partitionInt. Després es guarda el que ens torna la funció en un PairOfLists d'ints i es comprova que la funció s'ha executat de manera correcta. Per això, creem llistes amb el resultat que ens hauria de tornar la funció i comparem amb el que realment ens ha tornat la funció.
### 2.2. tesFloats
Aquest test comprova el funcionament de les tasques 2 i 3 utilitzant floats. Primer es crea una instància de la classe comparador que hem creat anomenada FloatComparator que implementa comparator i que conté la funció "compare" que compara dos floats. Després es crea els altres elements: la llista, el pivot, les llistes que contenen el resultat que han de tornar les funcions i les llistes que s'utilitzen a la tasca 3 per guardar els elements. Finalment, es crida a la funció "tests".
La funció "tests" s'encarrega d'executar totes les funcions de les tasques independentment de la classe que siguin els seus paràmetres, això vol dir que implementa genèrics per poder fer-ho i que podrem reutilitzar la funció per quan fem altres testos (per exemple en el cas dels tests dels Employees). Cada vegada que una de les funcions és executada, es crida a la funció resultChecker que comprova que el resultat que ha tornat la funció és el mateix que el resultat que hem especificat al principi del tot al PairOfLists anomenat results.
### 2.3. testEmployees
Aquest test comprova el funcionament de les tasques 2 i 3 utilitzant una jerarquia de classes. La jerarquia sol conte tres classes, l'Employee i dues subclasses d'aquesta anomenada Engineer i Mechanic. La classe Employee conte un nom, un DNI i un integer que diu quin nivell d'accés té aquest Employee dins l'empresa(AL). Aquesta classe també implementa comparable i això porta ha que també tingui implementada la funció compareTo que es necessita a les funcions per classificar-les en llistes. Perquè les funcions de les tasques entenguin que utilitzem el compareTo heretat de la classe pare hem d’especificar-ho amb <E extends Comparable<? super E>>. Engineer i Mechanic en estendre d'Employee també hereta aquests paràmetres i funcions.
També creem una classe que implementi comparator d'Employees anomenada EmployeeComparator i fem una instància d'ella. Aquesta treballa amb genèrics que siguin subclasses d’Employee, així depenent del test que vulguem fer podrem crear una instància amb la sublcasse que vulguem i així ens podem estalviar uns comodins. Tant com la funció compareTo com el comparador, comparen de la següent manera: si els dos elements tenen el mateix DNI o el mateix nivell d'accés(AL) es retornarà 0, i depenent de si un té un nivell d'accés superior o inferior al de l'altre, es retornarà 1 o -1.
El test testEmployees funciona igual que el testFloats que hem discutit abans. L'única diferencia, és que aquest test crea una llista d'Employees plena d’egnineers i Mechanics i un pivot Engineer i com que la funció "tests" és genèrica, la podem reutilitzar.
### 2.4. testEngineer
Fa el mateix que testEmployees però amb Engineers excepte les llistes que s’utilitzen a la tasca 3 que són d’Employees i el comparador és de Engineers.
